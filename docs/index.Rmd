---
title: "CellTrails: Inference of Temporal Gene Expression Dynamics of Branching Biological Processes from Single-cell Expression Data"
shorttitle: "CellTrails: Single-cell Data Analysis"
author:
- name: "Daniel Christian Ellwanger"
  affiliation: "Department of Otolaryngology - Head & Neck Surgery, and Institute for Stem Cell Biology and Regenerative Medicine, Stanford University School of Medicine, Stanford, CA 94305, USA"
  email: "dc.ellwanger.dev@gmail.com"
package: "CellTrails"
tags: ["Trajectory reconstruction", "Dimensionality reduction", "Clustering", "Single-cell", "Machine learning"]
abstract: |
  This manual describes the practical use of the _CellTrails_ implementation, an unsupervised algorithm for the _de novo_ chronological ordering, visualization and analysis of single-cell expression data. _CellTrails_ makes use of a geometrically motivated concept of lower-dimensional manifold learning, which exhibits a multitude of virtues that counteract intrinsic noise of single cell data caused by drop-outs, technical variance, and redundancy of predictive variables. _CellTrails_ enables the reconstruction of branching trajectories and provides an intuitive graphical representation of expression patterns along all branches simultaneously. It allows the user to define and infer the expression dynamics of individual and multiple pathways towards distinct phenotypes.

  We are pleased that you consider using _CellTrails_ in your research. A detailed theoretical description of the algorithm and its application to biological uses has been published in:
  
  __Ellwanger DC, Scheibinger M, Dumont RA, Barr-Gillespie PG, and Heller S. Transcriptional dynamics of hair-bundle morphogenesis revealed with CellTrails. _Cell Reports_ (Date);Issue.__

output: 
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    fig_width: 4.5
    fig_height: 3.5
vignette: |
  %\VignetteIndexEntry{Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

references:
- id: vdmaaten2008
  title: 'Visualizing high-dimensional data using t-SNE.'
  author:
  - family: van der Maaten
    given: L.J.P.
  - family: Hinton
    given: G.E.
  container-title: Journal of Machine Learning Research
  volume: 9
  page: 2579-2605
  type: article-journal
  issued:
    year: 2008
    
- id: belkin2003
  title: 'Laplacian eigenmaps for dimensionality reduction and data representation.'
  author:
  - family: Belkin
    given: M.
  - family: Niyogi
    given: P.
  container-title: Neural computation
  volume: 15
  page: 1373-1396
  type: article-journal
  issued:
    year: 2003
    
- id: sussman2012
  title: 'A consistent adjacency spectral embedding for stochastic blockmodel graphs.'
  author:
  - family: Sussman
    given: D.L.
  - family: Tang
    given: M.
  - family: Fishkind
    given: D.E.
  - family: Priebe
    given: C.E.
  container-title: J Am Stat Assoc
  volume: 107
  page: 1119-1128
  type: article-journal
  issued:
    year: 2012
    
- id: daub2004
  title: 'Estimating mutual information using B-spline functions--an improved similarity measure for analysing gene expression data.'
  author:
  - family: Daub
    given: C.O.
  - family: Steuer
    given: R.
  - family: Selbig
    given: J.
  - family: Kloska
    given: S.
  container-title: BMC Bioinformatics
  volume: 5
  page: 118
  type: article-journal
  issued:
    year: 2012
    
- id: ward1963
  title: 'Hierarchical grouping to optimize an objective function.'
  author:
  - family: Ward
    given: J.H.
  container-title: Journal of the American Statistical Association
  volume: 58
  page: 236-244
  type: article-journal
  issued:
    year: 1963
    
- id: peto1972
  title: 'Asymptotically efficient bank invariant test procedures (with discussion).'
  author:
  - family: Peto
    given: R.
  - family: Peto
    given: J.
  container-title: Journal of the Royal Statistical Society
  volume: Series A 135
  page: 185-206
  type: article-journal
  issued:
    year: 1972

- id: benjamini1995
  title: 'Controlling the false discovery rate: a practical and powerful approach to multiple testing.'
  author:
  - family: Benjamini
    given: Y.
  - family: Hochberg
    given: Y.
  container-title: Journal of the Royal Statistical Society
  volume: Series B 57
  page: 289-300
  type: article-journal
  issued:
    year: 1995
    
- id: kruskal1956
  title: 'On the shortest spanning subtree of a graph and the traveling salesman problem.'
  author:
  - family: Kruskal
    given: J.B.
  container-title: Proc Amer Math Soc
  volume: 7
  page: 48-50
  type: article-journal
  issued:
    year: 1956
    
- id: bedall1979
  title: 'Algorithm AS143. The mediancentre.'
  author:
  - family: Bedall
    given: F.K.
  - family: Zimmermann
    given: H.
  container-title: Appl Statist
  volume: 28
  page: 325-328
  type: article-journal
  issued:
    year: 1979

- id: sakoe1978
  title: 'Dynamic programming algorithm optimization for spoken word recognition.'
  author:
  - family: Sakoe
    given: H.
  - family: Chiba
    given: S.
  container-title: IEEE Transactions on Acoustics, Speech, and Signaling Processing
  volume: 26
  page: 43-49
  type: article-journal
  issued:
    year: 1978
  
- id: ggplot2
  title: 'Elegant graphics for data analysis.'
  author:
  - family: Wickham
    given: H.
  container-title: Springer-Verlag New York
  type: book
  issued:
    year: 2009
    
- id: biobase
  title: 'Orchestrating high-throughput genomic analysis with Bioconductor.'
  author:
  - family: Huber
    given: W.
  - family: Carey
    given: V.J.
  - family: Gentleman
    given: R.
  - family: Anders
    given: S.
  - family: Carlson
    given: M.
  - family: Carvalho
    given: B.S.
  - family: Bravo
    given: H.C.
  - family: Davis
    given: S.
  - family: Gatto
    given: L.
  - family: Girke
    given: T.
  - family: Gottardo
    given: R.
  - family: Hahne
    given: F.
  - family: Hansen
    given: K.D.
  - family: Irizarry
    given: R.A.
  - family: Lawrence
    given: M.
  - family: Love
    given: M.I.
  - family: MacDonald
    given: J.
  - family: Obenchain
    given: V.
  - family: Oles
    given: A.K.
  - family: Pages
    given: H.
  - family: Reyes
    given: A.
  - family: Shannon
    given: P.
  - family: Smyth
    given: G.K.
  - family: Tenenbaum
    given: D.
  - family: Waldron
    given: L.
  - family: Morgan
    given: M.
  container-title: Nature Methods
  volume: 12
  page: 115-121
  type: article-journal
  issued:
    year: 2015
    
- id: mahata2014
  title: 'Single-cell RNA sequencing reveals T helper cells synthesizing steroids de novo to contribute to immune homeostasis.'
  author:
  - family: Mahata
    given: B.
  - family: Zhang
    given: X.
  - family: Kolodziejczyk
    given: AA.
  - family: Proserpio
    given: V.
  - family: Haim-Vilmovsky
    given: L.
  - family: Taylor
    given: AE.
  - family: Hebenstreit
    given: D.
  - family: Dingler
    given: FA.
  - family: Moignard
    given: V.
  - family: Goettgens
    given: B.
  - family: Arlt
    given: W.
  - family: McKenzie
    given: AN.
  - family: Teichmann
    given: SA
  container-title: Cell Reports
  volume: 7(4)
  page: 1130-42
  type: article-journal
  issued:
    year: 2014 
    
- id: buettner2015
  title: 'Computational analysis of cell-to-cell heterogeneity in single-cell RNA-sequencing data reveals hidden subpopulations of cells.'
  author:
  - family: Buettner
    given: F.
  - family: Natarajan
    given: KN.
  - family: Casale
    given: FP.
  - family: Proserpio
    given: V.
  - family: Scialdone
    given: A.
  - family: Theis
    given: FJ.
  - family: Teichmann
    given: SA.
  - family: Marioni
    given: JC.
  - family: Stegle
    given: O.
  container-title: Nature Biotechnology
  volume: 33(2)
  page: 155-60
  type: article-journal
  issued:
    year: 2015

- id: scran
  title: 'A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor.'
  author:
  - family: Lun
    given: ATL.
  - family: McCarthy
    given: DJ.
  - family: Marioni
    given: JC.
  container-title: F1000Res.
  volume: 5
  page: 2122
  type: article-journal
  issued:
    year: 2016

- id: annotationdbi
  title: 'AnnotationDbi: Annotation Database Interface.'
  author:
  - family: Pages
    given: H.
  - family: Carlson
    given: M.
  - family: Falcon
    given: S.
  - family: Li
    given: N.
  container-title: R package version 1.40.0
  type: article-journal
  issued:
    year: 2017
    
- id: orgmmegdb
  title: 'org.Mm.eg.db: genome wide annotation for mouse.'
  author:
  - family: Carlson
    given: M.
  container-title: R package version 3.5.0
  type: article-journal
  issued:
    year: 2017
    
- id: destiny
  title: 'destiny: diffusion maps for large-scale single-cell data in R.'
  author:
  - family: Angerer
    given: P.
  - family: Haghverdi
    given: L.
  - family: Buettner
    given: M.
  - family: Theis
    given: FJ. 
  - family: Marr
    given: C. 
  - family: Buettner
    given: F. 
  container-title: Bioinformatics
  volume: 32
  page: 1241-1243
  type: article-journal
  issued:
    year: 2015

- id: scater
  title: 'Scater: pre-processing, quality control, normalisation and visualisation of single-cell RNA-seq data in R.'
  author:
  - family: McCarthy
    given: DJ.
  - family: Campbell
    given: KR.
  - family: Lun
    given: ATL.
  - family: Wills
    given: QF.
  container-title: Bioinformatics
  volume: 14
  page: 1179-1186
  type: article-journal
  issued:
    year: 2017
   
- id: fr
  title: 'Graph Drawing by Force-directed Placement.'
  author:
  - family: Fruchterman
    given: TMJ.
  - family: Reingold
    given: EM.
  container-title: Software - Practice and Experience
  volume: 21(11)
  page: 1129-1164
  type: article-journal
  issued:
    year: 1991   
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE) #, fig.width=4.5, fig.height=3.5, dpi=300 fig.align="left"
```

<!-- ---------------------------------- -->
# Prerequisites
<!-- ---------------------------------- -->
## Terminology
In the following, we use a general termonology to describe the biological data of interest. We analyze quantitative _expression values_ (e.g., RT-qPCR Log2Ex, RNA-Seq log2 counts, usf.) of _features_ (e.g., genes, transcripts, spike-in controls, usf.), which were obtained from individual _samples_ (e.g., single cells).

## Load Library
Before ready to use, the *CellTrails* libraries must be loaded into the _R_ environment:

```{r, eval=TRUE, message=FALSE, warning=FALSE}
library(CellTrails)
```

## Third-party Software: yEd
We strongly recommend to download and install the graph visualization software yEd (http://www.yworks.com/products/yed) [^1]. It provides great capabilities to perform planar embedding, visualization, and analysis of a trajectory graph produced by _CellTrails_.

## Input: SingleCellExperiment
*CellTrails* organizes its data in an object of Bioconductor's `r Biocpkg("SingleCellExperiment")` class. It provides all attributes required for smooth and user-friendly data processing and analysis of single cell data and enables interoperability between packages. Please, refer to the `r Biocpkg("SingleCellExperiment")` vignette for details. 

### Shape of Expression Data
*CellTrails* expects the expression data to be normalized and log-transformed; it is not required that features were filtered at this point. The expression data is expected to be available from the `logcounts` assay entry. If this entry is empty (check for its existence with function `assays`), the function `logcounts<-` can be used to store the log-normalized data in a `r Biocpkg("SingleCellExperiment")` object.

If your expression data is not stored in an object of class `r Biocpkg("SingleCellExperiment")`, we suggest to initiate an object from a numerical matrix composed of the log-normalized expression values; features should be listed in rows, and samples in columns (see _Example Datasets_). 

### Spike-in Controls
There is no need to remove spike-in controls from your `r Biocpkg("SingleCellExperiment")` object. *CellTrails* automatically ignores spike-in controls for its analysis, if they were properly annotated in the object using the function `isSpike` (see _Example Datasets_).

## Example Datasets
**exSim**

In this vignette, simulated data (with log-transformed Negative Binomial distributed expression counts) and real expression data are used to illustrate the functionality of the *CellTrails* package. 

The first dataset, `exSim`, is composed of expression values of 15,000 features measured in 100 samples; 80 spike-in transcripts were added.
```{r, eval=TRUE}
# Create example expression data
# with 15,000 features and 100 samples
set.seed(1101)
emat <- simulate_exprs(n_features=15000, n_samples=100)

# Create SingleCellExperiment object
exSim <- SingleCellExperiment(assays=list(logcounts=emat))

# Annotate ERCC spike-ins 
isSpike(exSim, "ERCC") <- 1:80
show(exSim)
```

**exBundle**

The second dataset, `exBundle`, contains transcript expression profiles of 183 genes expressed during sensory hair cell bundle maturation and function, which were quantified in the chicken utricle sensory epithelium at embryonic day 15 using multiplex RT-qPCR. Experimental metadata was generated during tissue preparation (cell origin) and cell sorting (uptake of FM1-43 dye indicating cell maturity). This data set is the foundation used for the development of *CellTrails*. If you use this dataset for your research, please cite:

Ellwanger DC, Scheibinger M, Dumont RA, Barr-Gillespie PG, and Heller S. "Transcriptional dynamics of hair-bundle morphogenesis revealed with CellTrails". *Cell Reports* Date;Issue. doi: 

```{r, eval=TRUE}
# Load bundle data
exBundle <- readRDS(system.file("exdata", "bundle.rds", package="CellTrails"))
```

<!-- ---------------------------------- -->
# Overview
<!-- ---------------------------------- -->

The following illustrates the typical sequence of steps performed during a *CellTrails* analysis and lists the available functions, respectively.

* Selection of trajectory features
    + ``filterTrajFeaturesByDL``
    + ``filterTrajFeaturesByCOV``
    + ``filterTrajFeaturesByFF``
*  Lower-dimensional manifold learning
    + ``embedSamples``
    + ``findSpectrum``
    + ``latentSpace``
    + ``plotManifold``
*  Clustering
    + ``findStates``
    + ``states``
    + ``plotStateSize``
    + ``plotStateExpression``
*  Determination of the trajectory topology
    + ``connectStates``
    + ``showTrajInfo``
    + ``trajComponents``
    + ``selectTrajectory``
    + ``plotStateTrajectory``
* Chronologically ordering of samples
    + ``fitTrajectory``
    + ``plotTrajectoryFit``
* Trajectory visualization
    + ``write.ygraphml``
    + ``read.ygraphml``
    + ``trajLayout``
    + ``plotMap``
* Identification of paths (trails) on the trajectory
    + ``landmarks``
    + ``userLandmarks``
    + ``addTrail``, ``removeTrail``
    + ``trailNames``
    + ``trails``
    + ``plotTrail``
* Inference of expression dynamics of trails
    + ``fitDynamic``
    + ``plotDynamic``
* Intra- and inter-trail expression dynamic comparison
    + ``contrastTrailExpr``

By calling the function `showTrajInfo`, an informative overview of the data relevant for, or stored by _CellTrails_ is printed. We suggest to use this function multiple times during a _CellTrails_ analysis, as it provides useful insights into the analysis' progress.

```{r, eval=TRUE}
showTrajInfo(exBundle)
```

The entries _logcounts_ and _Feature data_ correspond to the expression matrix and feature information provided and annotated by the user, respectively. _Pheno data_ contains metainformation for each sample stored by the user and by *CellTrails*. The entries _Trajectory data_, _Trajectories_ and _Trail data_ denote *CellTrails* specific information and will be described in detail in the respective section of this vignette.

<!-- ---------------------------------- -->
# Selection of Trajectory Features
<!-- ---------------------------------- -->
An expression matrix from an high-throughput experiment contains hundreds of features that bear no or little information about a sample's progress through the trajectory of interest. These non-relevant features not only increase the computational runtime of the trajectory reconstruction, but they also impair the accuracy of downstream analysis results. *CellTrails* assumes that key features show high expression variability during a sample's progression along the biological process under study. Therefore, *CellTrails* enables to unbiasedly filter the informative features. 

*Please note* that the following functions only indicates features used for dimensionality reduction, state detection and trajectory reconstruction; it does _not_ remove features from the assay stored in the `r Biocpkg("SingleCellExperiment")` object. Thus, all features are still available for *CellTrails* donwstream analyses capabilities, such as cluster analysis and inference of expression dynamics, as well as, for functions available from complementary analysis packages.

The names of trajectory features can be received from and set to a `r Biocpkg("SingleCellExperiment")` object using the function `trajFeatureNames`. The `showTrajInfo` function, as well, provides an overview of the selected trajectory features.

*Please note* that the following filter functions can be used incrementally, since statistical characteristics are only analyzed for already designated trajectory features. In other words, using the filters multiple times or combining the filters will result in a more stringent selection of trajectory features. Initially, all features in a `r Biocpkg("SingleCellExperiment")` (excluding spike-in controls), are assumed to be trajectory features.

## Filter by Detection Level
This filter determines trajectory features that are present in a disproportionate small number of samples. It removes features that are not expressed or that do not sufficiently reach the technological limit of detection. The detection level is defined as the fraction of samples in which a feature is detected, i.e., the relative number of samples having a feature's expression value greater than 0. If a threshold >= 1 is selected, its value is automatically converted to a relative fraction of the total sample count. The empirical cumulative distribution function of all samples and the fraction of removed features is shown.

```{r, eval=TRUE}
# Filter features expressed in at least 3 samples
tfeat <- filterTrajFeaturesByDL(exSim, threshold=2)
tfeat[1:5]

# Setting trajectory features to the object
trajFeatureNames(exSim) <- tfeat
showTrajInfo(exSim)
```

## Filter by Coefficient of Variation
This filter determines trajectory features with a narrow standard deviation (sd) with respect to its average expression (mean). This filter removes features with high expression and low variance, such as housekeeping genes. The coefficient of variation is computed by CoV(x) = sd(x)/mean(x). Features with a CoV(x) greater than a given threshold remain labeled as trajectory feature in the `r Biocpkg("SingleCellExperiment")` object. The empirical cumulative distribution function of all samples and the fraction of removed features is shown.

```{r, eval=TRUE}
# Filter features with COV > 0.5
tfeat <- filterTrajFeaturesByCOV(exSim, threshold=0.5)

# Setting trajectory features to the object
trajFeatureNames(exSim) <- tfeat
showTrajInfo(exSim)
```

## Filter by Fano Factor
This filter identifies the most variable features while considering their average expression level. Features are placed into 20 bins based on their mean expression. For each bin, the distribution of Fano factors, which is a windowed version of the index of dispersion (IOD = variance / mean), is computed and standardized (*Z*-score(x) = x/sd(x) - mean(x)/sd(x)). Highly variable features with a *Z*-score greater than a given threshold remain labeled as trajectory feature in the `r Biocpkg("SingleCellExperiment")` object. The parameter `min_expr` defines the minimum average expression level of a feature to be considered for this filter (default: 0). The Fano factor and the average expression is shown for each feature; filtered features are highlighted. 

```{r, eval=TRUE}
# Filter features with Z > 1.7
tfeat <- filterTrajFeaturesByFF(exSim, threshold=1.7)

# Setting trajectory features to the object
trajFeatureNames(exSim) <- tfeat
showTrajInfo(exSim)
```

## Blocking Uniformative Substructures
The functions `filterTrajFeaturesByCOV` and `filterTrajFeaturesByFF` allow to define a design matrix to account for systematic bias in the expression data (e.g., batch, gender or cell cycle). It should list the nuisance factors that should be blocked and their values per sample. It is suggested to construct the design matrix with the `model.matrix` function. Please see _Manifold Learning/Blocking Uniformative Substructures_ of this vignette for an example on how to create a proper design matrix.

## Using Alternative Methods
The function `trajFeatureNames` allows to designate any set of features as trajectory features. The only requirement is that the names in the set match the stored feature names in the `r Biocpkg("SingleCellExperiment")` object (check with function `featureNames`). For example, one could also use an abundance-dependent variance trend fit, as implemented in the `r Biocpkg("scran")` package [@scran], to indicate trajectory features:

```{r, eval=TRUE}
# Filter using scran
var_fit <- scran::trendVar(x=exSim, use.spikes=FALSE)
var_out <- scran::decomposeVar(x=exSim, fit=var_fit)
tfeat <- featureNames(exSim)[which(var_out$FDR < 0.01)]

# Setting trajectory features to the object
trajFeatureNames(exSim) <- tfeat
showTrajInfo(exSim)
```

*Please note* that filters from different packages can also be combined by subsetting the `r Biocpkg("SingleCellExperiment")` object with the trajectory features.

```{r, eval=TRUE}
# Reset: all features are trajectory features
trajFeatureNames(exSim) <- featureNames(exSim)

# Use CellTrails filter
trajFeatureNames(exSim) <- filterTrajFeaturesByDL(exSim, threshold=2, 
                                                  show_plot=FALSE)
trajFeatureNames(exSim) <- filterTrajFeaturesByCOV(exSim, threshold=0.5, 
                                                   show_plot=FALSE)

exSim_sub <- exSim[trajFeatureNames(exSim), ]

# Filter using scran
var_fit <- scran::trendVar(x=exSim_sub, use.spikes=FALSE)
var_out <- scran::decomposeVar(x=exSim_sub, fit=var_fit)
tfeat <- featureNames(exSim_sub)[which(var_out$FDR < 0.01)]

# Setting trajectory features to the object
trajFeatureNames(exSim) <- tfeat
showTrajInfo(exSim)
```

<!-- ---------------------------------- -->
# Manifold Learning
<!-- ---------------------------------- -->
The samples' expression profiles are shaped by many factors, such as developmental age, tissue region of origin, cell cycle stage, as well as extrinsic sources such as status of signaling receptors, and environmental stressors, but also technical noise. In other words, a single dimension, despite just containing feature expression information, represents an underlying combination of multiple dependent and independent, relevant and non-relevant factors, whereat each factor's individual contribution is non-uniform. To obtain a better resolution and to extract underlying information, *CellTrails* aims to find a meaningful low-dimensional structure - a manifold - that represents samples mainly by their latent temporal relation.

## Spectral Embedding
*CellTrails* aims to decipher the temporal relation between samples by computing a novel data representation which amplifies trajectory information in its first *n* dimensions. For this purpose, *CellTrails* employs spectral graph theory. Due to their locality-preserving character, spectral embedding techniques are advantageous because these consider the data's manifold structure, are insensitive to outliers and noise, are not susceptible to short-circuiting, and emphasize naturally occurring clusters in the data [@belkin2003; @sussman2012]. In a nutshell, *CellTrails* assumes that two samples that have a high statistical dependency are represented in close proximity along a trajectory. *CellTrails* captures the intrinsic data geometry as a weighted graph (nodes = samples, edges = statistical dependencies between pairs of samples) by means of fuzzy mutual information and uses spectral graph decomposition to unfold the manifold revealing the hidden trajectory information.

The spectral embedding is performed using the function `embedSamples` and results in a list with the eigenspace representation of the original expression data.

```{r, eval=TRUE}
# Spectral Embedding
se <- embedSamples(exBundle)
names(se)
```

*Please note* that this function can also be applied to any numerical matrix of interest.

## Dimensionality Reduction
*CellTrails* assumes that the expression vectors are lying on or near a manifold with a low dimensionality that is embedded in the higher-dimensional space. The number of dimensions can be reduced, which lowers noise (i.e., truncates non-relevant dimensions), while the geometry of the trajectory is emphasized.

The function `findSpectrum` helps to identify the intrisic dimensionality of the data. It determines the most informative dimensions based on the eigenvalues (spectrum) of the eigenspace. Components of the latent space are ranked by their information content. In the following example, *CellTrails* identifies relevant components by using a linear fit on the eigengaps of the first 100 eigenvalues.

```{r, eval=TRUE}
# Identify relevant components
d <- findSpectrum(se$eigenvalues, frac=100)
d
```

We suggest to assess the resulting Scree plot (eigengaps versus spectrum size) for whether the estimation of the unknown intrinsic dimensionality was reasonable. Otherwise, we recommend to adjust the parameter `frac` accordingly. 

*Please note* that considering too few components of the latent space may result in loss of information, while selecting lower ranked components could increase noise.

Next, we set the identified latent space to our `r Biocpkg("SingleCellExperiment")` object:
```{r, eval=TRUE}
latentSpace(exBundle) <- se$components[, d]
```

## Blocking Uninformative Substructures
Single-cell measurements are susceptible to the influence of confounders, such as batch, gender or cell cycle effects. Blocking these nuisance factors during manifold learning may be necessary to significantly improve the result of downstream data analyses, such as reconstruction of the temporal trajectory. Therefore, the function `embedSamples` can account for confounding effects via the parameter `design`, as will be demonstrated on the example of single-cell RNA-Seq data of murine T helper 2 cell (T~h~2) differentiation [@mahata2014]. In a nutshell, Buettner *et al.* [@buettner2015] identified cell cycle effects as major confounder in this dataset and applied a single-cell latent variable model (scLVM) approach to account for this factor. They unbiasedly identified then two cell populations, namely a group of partially and a group of fully differentiated cells. The normalized, log transformed and filtered scRNA-Seq data can be obtained from the supplementary materials of their article (Table S5 and S7); further, a curated list of T~h~2 marker genes, the scLVM-corrected expression matrix, and a binary cluster assignment for each cell can be downloaded.

For your convenience, the numeric expression matrix (here called `th2`) and the list of marker genes were already organized in a `r Biocpkg("SingleCellExperiment")` container. Here, the expression matrix consists of 7,063 selected genes (116 of which are marker genes) which have been detected in more than 3 of all 81 cells.
```{r, eval=TRUE}
th2 <- readRDS(system.file("exdata", "th2.rds", package="CellTrails"))
th2

# Number of markers
nMarkers <- sum(rowData(th2)$isMarker)
nMarkers

# Number of total genes
nGenes <- nrow(th2)
nGenes
```

First, we have a quick look into the unprocessed dataset. If the latent temporal factor is a major source of variance, two clusters, which separate fully from partially differentiated cells, should be detectable; if those clusters are not identifiable, the data is affected by uniformative substructures. We assume that T~h~2 marker genes should be enriched in the group of genes differentially expressed between clusters, i.e. the enrichment odds ratio should be > 1 and the enrichment *P*-value should be significant if cells were clustered by maturity.

```{r, eval=TRUE}
# Clustering in the original space
D <- dist(t(logcounts(th2)))
dendro <- hclust(D, method="ward.D2")
cluster <- cutree(dendro, k=2)

# Differential expression
pvals <- apply(logcounts(th2), 1, function(x) {
  wilcox.test(x[cluster == 1], 
              x[cluster == 2], 
              exact=FALSE)$p.value})
fdr <- p.adjust(pvals, method="fdr")

# Number of differentially expressed markers for FDR < 0.05
de <- names(fdr[fdr < 0.05]) #differentially expressed genes
deGenes <- length(de) #number of genes
deMarkers <- sum(rowData(th2[de, ])$isMarker) #number of markers

# Enrichment statistic
enrichment.test(deMarkers, nMarkers, deGenes, nGenes)
```
<!-- prod(diag(m)) / prod(diag(t(m)[, 2:1])) -->
<!-- m <- matrix(c(n_marker_de, 
              n_marker-n_marker_de, 
              n_genes_de-n_marker_de, 
              n_genes-n_genes_de+n_marker_de), ncol=2)-->
Since the enrichment is not significant (with an odds ratio < 1), we argue that cells were not properly separated by maturity in the original space.

To block the cell cycle effects, *CellTrails* expects a design matrix modeling the cell cycle stage as the explanatory factor for each cell. As the cell-cycle stage of each cell is not known in this data set, we need to predict cell cycle phases. In this example, we use the classifier `cyclon` from the `r Biocpkg("scran")` package [@scran]. To be able to run the algrithm properly, gene symbols were translated to Ensembl identifiers using Bioconductors' annotation database interface package `r Biocpkg("AnnotationDbi")` [@annotationdbi] and the mouse annotation data package `r Biocpkg("org.Mm.eg.db")` [@orgmmegdb].

*Please note* that these packages are not part of *CellTrails* and may needed to be installed first.

```{r, eval=TRUE, message=FALSE, warning=FALSE}
# Run cyclone
mcm <- readRDS(system.file("exdata", "mouse_cycle_markers.rds", 
                           package="scran"))
set.seed(1101)
cellCycle <- scran::cyclone(x=logcounts(th2), 
                            pairs=mcm, 
                            gene.names=rowData(th2)$ENSEMBL)

# Number of predicted phases
table(cellCycle$phases)
```

Let's create the respective design matrix using the `cyclon` classification scores.

```{r, eval=TRUE}
# Design matrix
cc_design <- model.matrix(~ cellCycle$scores$G1 + cellCycle$scores$G2M)
head(cc_design)
```

Next, we reduce the dimensionality using *CellTrails*. Passing the design matrix to `embedSamples` ensures that *CellTrails* properly regresses out the effects of the explanatory variables before learning the manifold. Then, we cluster the cells in the derived lower-dimensional space.

```{r, eval=TRUE}
# Perform Dimensionality Reduction with Design Matrix
se <- embedSamples(th2, design=cc_design)
d <- findSpectrum(se$eigenvalues, frac=60)
latentSpace(th2) <- se$components[, d]

# Clustering in Latent Space
D <- dist(latentSpace(th2))
dendro <- hclust(D, method="ward.D2")
cluster <- cutree(dendro, k=2)
```

We test the quality of clustering by quantifying the enrichment of marker genes in the set of differentially expressed genes.

```{r, eval=TRUE}
# Differential expression
pvals <- apply(logcounts(th2), 1, function(x) {
  wilcox.test(x[cluster == 1], 
              x[cluster == 2], 
              exact=FALSE)$p.value})
fdr <- p.adjust(pvals, method="fdr")

# Number of differentially expressed markers for FDR < 0.05
de <- names(fdr[fdr < 0.05]) #differentially expressed genes
deGenes <- length(de) #number of genes
deMarkers <- sum(rowData(th2[de, ])$isMarker) #number of markers

# Enrichment statistic
enrichment.test(deMarkers, nMarkers, deGenes, nGenes)
```

The marker gene enrichment is significant (*P*-value < 10^-6^) and the odds ratio is remarkably increased to ~6, indicating that the cells are now properly separated by maturity. In comparison, an enrichment odds ratio of 2.4 was achieved using the cell-cycle 'corrected' data and the clustering provided in the original scLVM study [@buettner2015].

*Please note* that the differential gene expression analysis using the *CellTrails* derived clusters was performed on the actual expression matrix and not the cell-cycle 'corrected' expression values. In contrast to scLVM, *CellTrails* blocks the nuisance variables for manifold learning only and keeps the original expression values for downstream analysis. This is due to the fact that the manipulated expression matrix does not represent the actual transcript levels measured in each cell, nor does it account for the uncertainty of estimation of the blocking factor terms. By this means, *CellTrails* protects against confounding effects without discarding information.

Besides cell cycle, technical confounders may also be relevant to be accounted for. Those can occur, for example, if samples were processed on different plates or if samples were pooled from multiple sequencing runs. In this case, a design matrix with the respective explanatory variables can be constructed and passed to `embedSamples`.

## Using Alternative Methods
If the user prefers to use an alternative approach for dimensionality reduction, any latent space can be set to a `r Biocpkg("SingleCellExperiment")` object. The latent space has to be a numerical matrix; rows represent samples and columns the components of the latent space. *CellTrails* uses by default spectral embedding, but the framework also operates well with any other spectral dimensionality reduction method, such as PCA (e.g., available in *CellTrails* via function `pca`) and diffusion maps (e.g., available via the `r Biocpkg("destiny")` package [@destiny]):

```{r, eval=TRUE}
# Make copy of example data
exAlt <- exBundle

# PCA
pca_result <- pca(exAlt)
d <- findSpectrum(pca_result$eigenvalues, frac=100)
latentSpace(exAlt) <- pca_result$components[, d]

# Diffusion maps
lcounts <- t(logcounts(exAlt))
dmaps_result <- destiny::DiffusionMap(lcounts, n_eigs = 101)
d <- findSpectrum(destiny:::eigenvalues(dmaps_result), frac=100)
latentSpace(exAlt) <- destiny:::eigenvectors(dmaps_result)[, d]
```

*Please note* that the function `latentSpace<-` accepts any numerical matrix. Therefore, any latent space with an already reduced number of dimensions can be assigned to a *CellTrailsSet* object with this function; eigenvalues are only used to determine the intrinsic dimensionality of the data set. 

## Visualization
*CellTrails* allows us to visualize an approximation of the learned lower-dimensional manifold in two dimensions. *CellTrails'* plot function `plotManifold` uses t-distributed stochastic neighbor embedding (tSNE) [@vdmaaten2008] to illustrate the arrangement of the samples in the latent space in a two-dimensional plot. Points denote individual samples, the colorization indicates either a metadata label or expression of a single feature. Empty points denote a missing label or missing expression value (non-detects). Available phenotype lables can be listed with the function `phenoNames`, available features with `featureNames`, respectively.

```{r, eval=TRUE}
# Show available phenotype labels
phenoNames(exBundle)

# Show sample metainformation 'fm143 dye uptake'
plotManifold(exBundle, color_by="phenoName", name="fm143")
```

The function `plotManifold` returns a `ggplot` object [@ggplot2] from the `r CRANpkg("ggplot2")` package, which can be adapted by the user's needs and preferences (for details, please refer to the `r CRANpkg("ggplot2")` manual; to save the plot see function `ggsave`). The 2D representation of the latent manifold is by default already stored the the `r Biocpkg("SingleCellExperiment")` object (also accessible via `reducedDims`). However, the `plotManifold` function provides the parameter `recalculate`. For example, if we want to change the `perplexity` parameter of the tSNE calculation, then we set `recalculate=TRUE`. The new tSNE result needs to be set to the `r Biocpkg("SingleCellExperiment")` object using the `manifold2D` function, respectively.

```{r, eval=TRUE}
# Show feature expression (e.g., gene TECTA)
gp <- plotManifold(exBundle, color_by="featureName", name="TECTA", recalculate=TRUE)
gp

# Store tSNE result
manifold2D(exBundle) <- gp

# Show feature expression (e.g., genes MYO7A)
plotManifold(exBundle, color_by="featureName", name="MYO7A")
```

<!-- ---------------------------------- -->
# Clustering
<!-- ---------------------------------- -->
## Hierarchical Spectral Clustering

To identify cellular subpopulations, *CellTrails* performs hierarchical clustering via minimization of a square error criterion [@ward1963] in the lower-dimensional space. To determine the number of clusters, *CellTrails* conducts an unsupervised *post-hoc* analysis. Here, it is assumed that differential expression of assayed features determines distinct cellular stages. Hierarchical clustering in the latent space generates a cluster dendrogram. *CellTrails* makes use of this information and identifies the maximal fragmentation of the data space, i.e. the lowest cutting height in the clustering dendrogram that ensures that the resulting clusters contain at least a certain fraction of samples. Then, processing from this height towards the root, *CellTrails* iteratively joins siblings if they do not have at least a certain number of differentially expressed features. Statistical significance is tested by means of a two-sample non-parametric linear rank test accounting for censored values [@peto1972]. The null hypothesis is rejected using the Benjamini-Hochberg [@benjamini1995] procedure for a given significance level. The number of clusters can impact the outcome of the trajectory reconstruction and therefore, this step might require some parameter tuning depending on the input data (for more information on the parameters call `?findStates`).

```{r, eval=TRUE}
cl <- findStates(exBundle, min_size=0.01, min_feat=5, max_pval=1e-4, min_fc=2)
head(cl)
```

The clusters identified by *CellTrails* are referred to as states along the trajectory. The function `states` can be used to set the clusters to the `r Biocpkg("SingleCellExperiment")` object.

```{r, eval=TRUE}
# Set clusters
states(exBundle) <- cl
```

State assignments are stored as sample metainformation and can be either recieved via `colData` or `states`. Since `CellTrails` operates on a `r Biocpkg("SingleCellExperiment")` object, its results can be easily used by other packages. For example, visualizing a principal component analysis with `r Biocpkg("scater")` [@scater]:
```{r, eval=TRUE}
# Plot scater PCA with CellTrails cluster information
scater::plotPCA(exBundle, colour_by="CellTrails.state")
```

## Using Alternative Methods
Technically, the function `states<-` allows to set any clustering result to a `r Biocpkg("SingleCellExperiment")` object. Any numeric, character or factor vector containing the cluster assignments for each sample is accepted.

## Visualization
As before, we can visualize the approximated lower-dimensional manifold and colorize each sample by its assigned state.
```{r, eval=TRUE}
# States are now listed as phenotype
phenoNames(exBundle)

# Show manifold
plotManifold(exBundle, color_by="phenoName", name="state")
```

The function `plotStateSize` generates a barplot showing the absolute sizes of each state.
```{r, eval=TRUE}
plotStateSize(exBundle)
```

Further, violin plots can be produced showing the expression distribution of a feature per state. Each point displays the feature's expression value in a single sample. A violine represents a vertically mirrored density plot on each side.
```{r, eval=TRUE}
plotStateExpression(exBundle, feature_name="CALB2")
```

<!-- ---------------------------------- -->
# Sample Ordering
<!-- ---------------------------------- -->
*CellTrails* assumes that the arrangement of samples in the computed latent space constitutes a trajectory. *CellTrails* aims to place single samples along a maximum parsimony tree, which resembles a branching developmental continuum. Distances between samples in the latent space are computed using the Euclidean metric.

## State Trajectory Graph
To avoid overfitting and to facilitate the accurate identification of bifurcations, *CellTrails* simplifies the problem. Analogous to the idea of a 'broken-stick regression', *CellTrails* groups the data and performs linear fits to separate trajectory segments, which are determined by the branching chronology of states. This leaves the optimization problem of finding the minimum number of associations between states that maximize the total parsimony. In theory, this problem can be solved by any minimum spanning tree algorithm. *CellTrails* adapts this concept by assuming that adjacent states should be located nearby and, therefore, share a relative high number of neighboring samples.

Each state defines a submatrix of samples that is composed of a distinct set of data vectors, i.e. each state is a distinct set of samples represented in the lower-dimensional space. For each state, *CellTrails* identifies the *l*-nearest neighbors to each state's data vector and takes note of their state memberships and distances. This results in two vectors of length *l* times the state size. Subsequently, *CellTrails*  removes spurious neighbors (outliers/false-positive neighbors), which are statistically too distal. For each state *CellTrails* calculates the relative frequency on how often a state occurs in the neighborhood of a given state, which is referred to as the interface cardinality scores. 

*CellTrails* implements a greedy algorithm to find the tree maximizing the total interface cardinality score, similar to Kruskal's minimum spanning tree algorithm [@kruskal1956]. The graph construction has a relaxed requirement (number of edges < number of nodes) compared to a tree (number of edges = number of nodes - 1), which may result in a graph having multiple tree components (= forest) indicating potentially independent trajectories or isolated nodes. 

*Please note* that the function `connectStates` can be adjusted, such that the resulting number of components may be lower or higher by increasing or decreasing the parameter `l`, respectively.

```{r, eval=TRUE}
# State trajectory graph computation
exBundle <- connectStates(exBundle, l=10)
```
In our example dataset, we identified two components, as indicated by the _Trajectories_ entity of the `showTrajInfo` function: component 1 is a tree with 10 states connected by 9 edges, and component 2 is an isolated state (one state, zero edges).

```{r, eval=TRUE}
# Show trajectory information
showTrajInfo(exBundle)
```

The function `trajComponents` provides us information about the states contained in each component.
```{r, eval=TRUE}
# Show trajectory information
trajComponents(exBundle)
```

Further, the inferred state trajectory graph can be visualized using `plotStateTrajectory`. If the graph is a forest, the parameter `component` can be used to define which tree should be shown. The optional parameters `point_size` and `label_offset` are useful to adjust the graph layout, the size of the points and the relative position of the point labels, respectively. Let's have a look at the FM1-43 uptake and the _CALB2_ expression in component 1:

```{r, eval=TRUE}
# FM1-43 uptake
plotStateTrajectory(exBundle, color_by="phenoName", name="fm143", 
                    component=1, point_size=1.5, label_offset=4)

```

The `plotStateTrajectory` function uses the Fruchterman-Reingold graph layout algorithm [@fr] for visualization. If the user needs to re-compute the layout, it can be achieved by setting the parameter `recalculate=TRUE`. The new layout should then be stored to the `r Biocpkg("SingleCellExperiment")` object.

```{r, eval=TRUE}
# FM1-43 uptake
gp <- plotStateTrajectory(exBundle, color_by="phenoName", name="fm143", 
                          component=1, point_size=1.5, label_offset=4, 
                          recalculate=TRUE)
gp

# Store layout
stateTrajLayout(exBundle) <- gp

# CALB2 exoression
plotStateTrajectory(exBundle, color_by="featureName", name="CALB2", 
                    component=1, point_size=5)
```

## Aligning Samples Onto the Trajectory
For the sake of simplicity and performance, it makes sense to conduct subsequent steps for each component individually. In this case, we select the tree formed by graph component 1 with 896 samples for our example data analysis.

```{r, eval=TRUE}
# Select trajectory
exBundle <- selectTrajectory(exBundle, component=1)
```

The function `trajSampleNames` returns the names of the 896 samples which were selected for trajectory reconstruction. If further details or analyses are of interest for this set of samples exclusively, the `r Biocpkg("SingleCellExperiment")` object can be subset.
```{r, eval=TRUE}
# Subset SingleCellExperiment object by
# trajectory sample names
exBundle_subset <- exBundle[, trajSampleNames(exBundle)]

# Plot state sizes
plotStateSize(exBundle_subset)
```

As expected, the isolated state S3 (trajectory graph component 2) is not contained in this subset.

The selected graph component defines the trajectory backbone. The function `fitTrajectory` embeds the trajectory structure in the latent space by computing straight lines passing through the mediancentres [@bedall1979] of adjacent states. Then, a fitting function is learned. Each sample is projected to its most proximal straight line passing through the mediancentre of its assigned state. Here, whenever possible, orthogonal projections onto line segments between two mediancentres are preferred to line segments which are only incident to a single median centre. Fitting deviations are given by the Euclidean distance between the sample's location and the straight line, and are indicated by an aggregated statistic (Mean Squared Error, MSE) shown by `showTrajInfo` and can be directly accessed via `trajResiduals`. Finally, a weighted acyclic trajectory graph can be constructed based on each sample's position along its straight line. Nodes in this graph are samples; edges are constructed between neighboring samples. Each edge is weighted by the distance between its nodes along the straight line. 

```{r, eval=TRUE}
# Align samples onto trajectory
exBundle <- fitTrajectory(exBundle)
showTrajInfo(exBundle)

trajResiduals(exBundle)[1:5]
```

Of note, the fitting function implies potential side branches in the trajectory graph; those could be caused due to technical variance or encompass samples that were statistically indistinguishable from the main trajectory given the selected features used for trajectory reconstruction. The `plotTrajectoryFit` function shows the trajectory backbone (longest shortest path between two samples) and the fitting deviations of each sample indicated by the perpendicular jitter.

```{r, eval=TRUE}
plotTrajectoryFit(exBundle)
```

<!-- ---------------------------------- -->
# CellTrails Maps
<!-- ---------------------------------- -->
## Graph Layout

*CellTrails* portrays a computed trajectory as collection of trails that can be found in a landscape shaped by individual expression dynamics. To generate such a topographic trail map - the *CellTrails* map - a two-dimensional spatiotemporal ordination of the expression matrix has to be computed. This can be done by any graph layout algorithm using the structural information from the trajectory graph, which is composed of nodes (=samples) and edges (=chronological relation between samples). 
We found that the freely available graph visualization software _yEd_ (http://www.yworks.com/products/yed) has great capabilities to visualize and analyze a trajectory graph. An optimal layout is planar, i.e. it exhibits no crossing edges or overlapping nodes.

Therefore, *CellTrails* enables to export and import the trajectory graph structure using the common _graphml_ file format. This file format can be interpreted by most third-party graph analysis applications, allowing the user to subject the trajectory graph to a wide range of (tree) layout algorithms. In particular, the exported file has additional ygraph attributes best suited to be used with _yEd_, which is freely available for all major platforms (Windows, Mac OS, and Linux).

```{r, eval=FALSE}
write.ygraphml(exBundle, file="yourFileName.graphml")
```

Let's open the exported graphml file in _yEd_:

```{r, eval=TRUE, echo=FALSE}
pth <- "img/yEd_1.gif" #system.file("img", "yEd_1.gif", package="CellTrails")
knitr::include_graphics(path=pth)
```

If a layout has already been defined for a `r Biocpkg("SingleCellExperiment")` object, the samples' coordinates will be listed in the exported graphml file and will be directly interpreted by _yEd_. In this example, no layout was defined yet and therefore, all samples (nodes) are overlapping.

*Please note* that the export function `write.ygraphml` colorizes automatically nodes by their assigned state. However, it is possible to colorize and label nodes by any phenotype or feature expression data stored in the `r Biocpkg("SingleCellExperiment")` object. For example, we could colorize the nodes by the recorded FM1-43 dye intensity to get an idea where the trajectory might start and end (a high FM1-43 dye indicates mature cells) and label the nodes by their determined state by setting the parameters `color_by="phenoName"`, `name="fm143"` and `label="state"`. Nodes with a missing phenotype information are not colorized and remain transparent.

Next, we layout the graph. Since the trajectory resembles a tree structre, we use a tree algorithm. We found that routing the trajectory graph in a quasi-radial style, called balloon style, works very well for our case. The layouter can be selected via  _Layout_ $\rightarrow$ _Tree_ $\rightarrow$ _Balloon_. The following parameter setting was used in the original _CellTrails_ publication:

```{r, eval=TRUE, echo=FALSE}
pth <- "img/yEd_2-3.gif" #system.file("img", "yEd_2-3.gif", package="CellTrails")
knitr::include_graphics(path=pth)
```

Let's run the algorithm to compute the layout:

```{r, eval=TRUE, echo=FALSE}
pth <- "img/yEd_4.gif" #system.file("img", "yEd_4.gif", package="CellTrails")
knitr::include_graphics(path=pth)
```

*Please note* that edge crossings (i.e., two or more edges overlap) are not useful and if they occur we suggest to re-run the layouter with different parameters before saving the layout. Using either your mouse or the _View_ $\rightarrow$ _Zoom In_ option allows to have a closer look. If we want to have the trajectory progressing from bottom left to bottom right (based on a specific feature expression or phenotype label), we need to transform the graph. This can be done via _Tools_ $\rightarrow$ _Geometric transformations_. Here, we select _Mirror on Y axis_ and _Mirror on X axis_.

```{r, eval=TRUE, echo=FALSE}
pth <- "img/yEd_5-6.gif" #system.file("img", "yEd_5-6.gif", package="CellTrails")
knitr::include_graphics(path=pth)
```

Finally, the file can be saved via _File_ $\rightarrow$ _Save_ and reimported to R. 

```{r, eval=FALSE}
tl <- read.ygraphml("yourFileName.graphml")
```

For illustration purposes, the computed trajectory layout for the example dataset is available within this package.

```{r, eval=TRUE, echo=FALSE}
par(mar=c(0,0,0,0))
```

```{r, eval=TRUE, fig.width=3.5, fig.height=3.5}
# Import layout
tl <- read.ygraphml(system.file("exdata", "bundle.graphml", 
                                package="CellTrails"))

# Plot layout
plot(tl[,1:2], axes=FALSE, xlab="", ylab="", pch=20, cex=.25)
```

Finally, we set the trajectory layout to the `r Biocpkg("SingleCellExperiment")` object using the `trajLayout` function. Here, the parameter `adjust` indicates if edge lengths should be adjusted, such that they correspond to the inferred pseudotime.
```{r, eval=TRUE, fig.width=3.5, fig.height=3.5}
# Adjust layout and store to object
trajLayout(exBundle, adjust=TRUE) <- tl

showTrajInfo(exBundle)

# Plot adjusted layout
plot(trajLayout(exBundle), axes=FALSE, xlab="", ylab="", pch=20, cex=.25)
```

**Sidenote**. It is not a requirement to use yEd. The trajectory layout can also be defined by the user otherwise. The minimum requirement is, that the coordinates of each sample are stored in a `data.frame` whose row names correspond to the trajectory sample names. The sample names can be pulled from the `r Biocpkg("SingleCellExperiment")` object using the function `trajSampleNames`. The layout can then be set using the accessor function `trajLayout` accordingly.

## Plot Maps
After generating the layout, a two-dimensional visualization of the trajectory can be drawn. Here, the line represents the trajectory and individual points represent the samples. This plot type either colorizes individual samples by a metadata label (as available via `phenoNames`) or it shows the topography of a given feature's expression landscape (as available via `featureNames`). When metadata are being visualized, the grey line represents the trajectory and the individual points represent samples. Samples that do not have a specific metadata label or a missing value are not shown. Let's visualize how the cellular FM1-43 uptake distributes along the trajectory:
```{r, eval=TRUE}
plotMap(exBundle, color_by="phenoName", name="fm143")
```

In the topographical plot, a smooth surface is fitted and values are predicted for a regular grid resulting in the shown map topography; the red line signifies the trajectory. Let's take a view into the _ATOH1_ expression landscape, an early key transcription factor during sensory hair cell development:

```{r, eval=TRUE}
plotMap(exBundle, color_by="featureName", name="ATOH1", type="surface.fit")
```

Let's have a look into the standard error of the predicted expression surface by setting the parameter `type`.
```{r, eval=TRUE}
plotMap(exBundle, color_by="featureName", name="ATOH1", type="surface.se")
```

Alternatively, *CellTrails* enables to show the samples only, instead of the whole fitted expression surface. Here, we have two options: either the raw expression or the smoothed values.

```{r, eval=TRUE}
# Raw
plotMap(exBundle, color_by="featureName", name="ATOH1", type="raw")

# Smoothed
plotMap(exBundle, color_by="featureName", name="ATOH1", type="surface.fit", 
        samples_only=TRUE)
```

<!-- ---------------------------------- -->
# Expression Dynamics
<!-- ---------------------------------- -->
During the trajectory fitting process, landmarks are automatically identified on the trajectory: trail heads (leafs), _H_, and branching points, _B_. The assigned landmark IDs can be obtained via `landmarks`. We use this information to define individual trails along the trajectory.

## Trail Definition
Trails are usful to infer expression dynamics of features along subsections of the trajectory. A trail denotes a path between two landmarks. To be able to properly define a trail, we display the available landmark points on the trajectory map.

```{r, eval=TRUE}
plotMap(exBundle, color_by="phenoName", name="landmark")
```

Based on the experimental metainformation and the expression pattern of marker features, we identified in the original *CellTrails* publication path _B3_ to _H9_ as developmental trail toward a striolar sensory hair bundle morphology, and _B3_ to _H1_ as developmental trail toward an extrastriolar bundle morphology. Let's mark those trails on the map using the function `addTrail`. 

```{r, eval=TRUE}
# Define trails
exBundle <- addTrail(exBundle, from="B3", to="H9", name="TrS")
exBundle <- addTrail(exBundle, from="B3", to="H1", name="TrES")

showTrajInfo(exBundle)
```

Next, we want to make sure that the intended trails were extracted by showing the trajectory map and highlight the defined trails along with its corresponding pseudotime.

```{r, eval=TRUE}
plotTrail(exBundle, name="TrS")
plotTrail(exBundle, name="TrES")
```

The function `addTrail` automatically extracts the samples and their pseudotime along the trail by computing the shortest path between the trail start and end. 
```{r, eval=TRUE}
# Get trail names
trailNames(exBundle)

# Get trail pseudotime
trails(exBundle)[1:5, ]
```

The pseudotime information is automatically stored as sample metadata (see `phenoNames`). For example, we could plot it on the lower-dimensional manifold.
```{r, eval=TRUE}
# Get trail names
plotManifold(exBundle, color_by="phenoName", name="TrS")
```

Also, the data is accessible via `colData` of the `r Biocpkg("SingleCellExperiment")` object and can therefore be analyzed using alternative packages. For example, colorizing the trail TrS in a principal component analysis using the `r Biocpkg("scater")` package [@scater].

```{r, eval=TRUE}
# Plot scater PCA with CellTrails pseudotime information
scater::plotPCA(exBundle, colour_by="CellTrails.TrS")
```

*Please note* that trails can be renamed with `trailNames<-` and removed with `removeTrail`, respectively. Adding another trail with the same name, will show a warning message and override the existing definition.

## Defining Subtrails
It might be needed to define subtrails if trails overlap. This is neccessary if the dynamics of one trail are subdynamics of another trail. Because pseudotime mirrors the location of each datapoint in the latent space, a significant gap in pseudotime could indicate separate sample populations. However, these populations have only subtle feature expression profile differences and were linearly aligned in the latent space. Since pseudotime can also be interpreted as a function of transcriptional change, one can argue that these populations undergo the same expression program (for the selected features), with the small but distinct difference that samples ordered at the terminal end of the longer trail up- or down-regulate additional features late during their maturation. Thus, trails can overlap, while one trail is a subtrail of the longer trail.

### Using yEd
_U_ landmarks that are needed to define a subtrail can be determined by the user, as demonstrated in the following.

First, we want to give a rational for selecting a specific node. As described in the original _CellTrails_ article, we found a gap in pseudotime near the terminal end of trail TrES, which might indicate that the terminal state can be split, and two trails are actually overlapping. This gap becomes already quite obvious visually when we utilize _yEd_ to have a closer look into the trajectory graph. First, we export the graph. By default, nodes are colorized by state (see _CellTrails Maps / Graph Layout_).

```{r, eval=FALSE}
write.ygraphml(exBundle, file='yourFileName.graphml')
```

Then we open the graphml file in _yEd_. The gap in the purple colored population is obvious:

```{r, eval=TRUE, echo=FALSE}
pth <- "img/yEd_7.gif" #system.file("img", "yEd_7.gif", package="CellTrails")
knitr::include_graphics(path=pth)
```

To indicate this sample as landmark, we simply change the shape of this node. This can be any shape, but not _ellipse_, which is used as default for other nodes. The shape can be changed using the _Properties View_ panel on the right border of the _yEd_ application. 

```{r, eval=TRUE, echo=FALSE}
pth <- "img/yEd_8.gif" #system.file("img", "yEd_8.gif", package="CellTrails")
knitr::include_graphics(path=pth)
```

After saving the layout, it can be reimported to *CellTrails* and the landmark can be used to define the subtrail:

```{r, eval=TRUE, echo=FALSE}
userLandmarks(exBundle) <- c("Cell-8-57")
```
```{r, eval=TRUE}
# Trail Identification
plotMap(exBundle, color_by="phenoName", name="landmark")
exBundle <- addTrail(exBundle, from="B3", to="U1", name="TrES*")
plotTrail(exBundle, name="TrES*")
showTrajInfo(exBundle)
```
```{r, eval=TRUE, echo=FALSE}
userLandmarks(exBundle) <- NULL
exBundle <- removeTrail(exBundle, "TrES*")
```

*Please note* that the trajectory graph can also be exported having all landmarks highlighted. This is particulary helpful if user-defined landmarks need to be changed.

```{r, eval=FALSE}
# Export Trajectory Graph Layout with sample names
write.ygraphml(exBundle, file='yourFileName.graphml', 
               color_by="phenoName", name="landmark", 
               node_label="landmark")
```

```{r, eval=TRUE, echo=FALSE}
pth <- "img/yEd_9.gif" #system.file("img", "yEd_9.gif", package="CellTrails")
knitr::include_graphics(path=pth)
```

Here, blue nodes denote user-defined landmarks, green nodes are branching points and red nodes are leafs. Landmark IDs, as listed by `landmarks`, are indicated as node names, respectively.

### Using R
A visual and empiric identification of user-defined landmarks can be helpful, but scientifically more appropriate is a statistical approach. For this purpose we analyze the distribution of all lagged differences along trail TrES. Here, we make use of the pseudotime information of each trail, respectively. 

```{r, eval=TRUE, include=FALSE}
dev.off()
```

```{r, eval=TRUE}
# Extract pseudotime of TrES
ptime <- trails(exBundle)[, "TrES"]

# Subset SingleCellExperiment set
# to samples which are part of trail TrES
trES <- exBundle[, !is.na(ptime)]

# Order samples by pseudotime
o <- order(trails(trES)[, "TrES"])
trES <- trES[, o]
ptime <- trails(trES)[, "TrES"]
names(ptime) <- colnames(trES)

# Lagged pseudotime values per state
ptime_states <- split(ptime, states(trES))
lptime <- lapply(ptime_states, 
                 function(x){y <- diff(sort(x)); y[-length(y)]})

bp <- boxplot(lptime, horizontal=TRUE, 
              ylab="State", xlab="Pseudotime delta", las=2)
```

The boxplot statistics indicate that there is a strong outlier in state S9 (which is termed state _i_ in the original *CellTrails* article). Let's extract the sample right before the leap.

```{r, eval=TRUE}
leap <- lptime$S9[which.max(lptime$S9) - 1]
names(leap)
```

The function `userLandmarks<-` enables us to (re-)define the set of user landmarks.

```{r, eval=TRUE}
userLandmarks(exBundle) <- names(leap)

# Trail Identification
plotMap(exBundle, color_by="phenoName", name="landmark")
exBundle <- addTrail(exBundle, from="B3", to="U1", name="TrES*")
plotTrail(exBundle, name="TrES*")
showTrajInfo(exBundle)
```

*Please note* that all user-defined landmarks can be removed using `userLandmarks(exBundle) <- NULL`.

## Inference of Dynamics
*CellTrails* defines pseudotime as the geodesic distance of each node of the trail from the start node. To learn the expression level of a feature as a function of pseudotime, *CellTrails* used generalized additive models (GAM) with a single smoothing term with five basis dimensions. Here, for each feature, *CellTrails* introduces prior weights for each observation to lower the confounding effect of missing data to the maximum-likelihood-based fitting process.

Feature expression as a function of pseudotime along an individual trail can be plotted with the `plotDynamic` function. This results in the fitted dynamic function (= black line) and the individual expression per sample (= points represent samples colored by their state membership). For example, the expression of the calcium buffer _CALB2_ during extrastriolar hair cell development can be displayed as follows: 

```{r, eval=TRUE}
plotDynamic(exBundle, feature_name="CALB2", trail_name="TrES")
```

*Please note* that the fitting function automatically scales pseudotime between 0 and 100% for each trail.

The fit information can be extracted via function `fitDynamic` and used for further downstream analyses:

```{r, eval=TRUE}
fit <- fitDynamic(exBundle, trail_name="TrES", feature_name="CALB2")

summary(fit)
range(fit$pseudotime)
range(fit$expression)

# Predict expression at 0%, 25%, 50%, 75% and 100% of pseudotime
timepoints <- data.frame(x=c("0%"=0, "25%"=.25, "50%"=.5, "75%"=.75, "100%"=1))
predict(fit$gam, newdata=timepoints)
```

## Dynamic Comparison: Within Trails
*CellTrails* allows the analysis and comparison of the expression of multiple features along a single trail. For example, the expression dynamics of the acting crosslinkers *FSCN1* and *FSCN2* can be displayed in a single plot as follows:

```{r, eval=TRUE}
plotDynamic(exBundle, feature_name=c("FSCN1", "FSCN2"), trail_name="TrES")
```

By using the fitting function `fitDynamic`, the similarity/correspondence between curves can be quantified. This allows a quantitative assessment of the observed anticorrelation seen in the plot above between _FSCN1_ and _FSCN2_:

```{r, eval=TRUE}
fscn1_fit <- fitDynamic(exBundle, trail_name="TrES", feature_name="FSCN1")
fscn2_fit <- fitDynamic(exBundle, trail_name="TrES", feature_name="FSCN2")

# Correlation
cor(fscn1_fit$expression, fscn2_fit$expression)
```

## Dynamic Comparison: Between Trails
Genes have non-uniform expression rates and each trail has a distinct set of upregulated features, but also contains unequal numbers of samples. Since pseudotime is computed based on expression differences between individual samples, the pseudotime axis may be distorted, leading to stretched or compressed sections of longitudinal expression data that make comparisons of such trails challenging. To align different trails, despite these differences, *CellTrails* employs a strategy that has long been known in speech recognition, called dynamic time warping [@sakoe1978]. Feature expression dynamics are modeled analogous to how dynamic time warping is used to align phonetic dynamics present in speech. Innate non-linear variation in the length of individual phonemes (i.e., states) is appropriately modeled, which results in stretching and shrinking of word (i.e., trail) segments. This allows the computation of inter-trail alignment warps of individual expression time series that are similar but locally out of phase. The overall dissimilarity between two expression time series can be estimated by the root-mean-square deviation (_RMSD_), the total deviation (_TD_), the area between curves (_ABC_), or Pearson's correlation coefficient (_COR_) over all aligned elements. The warp and the corresponding quantitative score can be computed using the function `contrastTrailExpr`.

```{r, eval=TRUE}
# Compare ATOH1 dynamic
# Root-mean-square deviation
contrastTrailExpr(exBundle, feature_names=c("ATOH1"), 
                  trail_names=c("TrS", "TrES"), score="RMSD")

# Total deviation
contrastTrailExpr(exBundle, feature_names=c("ATOH1"), 
                  trail_names=c("TrS", "TrES"), score="TD")

# Area between curves
contrastTrailExpr(exBundle, feature_names=c("ATOH1"), 
                  trail_names=c("TrS", "TrES"), score="ABC")

# Pearson's correlation coefficient
contrastTrailExpr(exBundle, feature_names=c("ATOH1"), 
                  trail_names=c("TrS", "TrES"), score="COR")
```

In this example, _ATOH1_ is expected to have a highly similar dynamic between both trails. Therefore, _RMSD_, _TD_, _ABC_ values should be low and _COR_ values high relative to other assayed features.

To identify features that differ between two trails, we can compute the divergence for all features and analyze the *Z*-score distribution as derived by `scale`:

```{r, eval=TRUE}
# Compare TrS and TrES dynamics
# Root-mean-square deviation
all_rmsd <- contrastTrailExpr(exBundle, 
                              trail_names=c("TrS", "TrES"), score="RMSD")

# Identify highly differing features
all_rmsd <- all_rmsd[all_rmsd > 0]
zscores <- scale(log(all_rmsd))
sort(all_rmsd[zscores > 1.65])
```

## Parallelization
In the case one wants to compare a large number of features (e.g. from an RNA-Seq experiment), the computation can be significantly sped up by parallel computing. In this example, we use the package `r CRANpkg("doSNOW")`, but any other package may also be used for this purpose.

```{r, eval=FALSE}
library(doSNOW)
# Register parallel backend
cpu.cl <- makeCluster(parallel::detectCores() * 2)
registerDoSNOW(cpu.cl)

# Compute warps
fnames <- featureNames(exBundle)
all_rmsd <- foreach(i=seq_along(fnames), .combine=rbind)  %dopar%  {
  g <- fnames[i]
  CellTrails::contrastTrailExpr(exBundle, 
                                feature_name=g, 
                                trail_names=c("TrES", "TrS"), 
                                score="RMSD")
}
stopCluster(cpu.cl)
all_rmsd <- all_rmsd[, 1]
names(all_rmsd) <- fnames
```
```{r, eval=TRUE}
# Identify highly differing features
all_rmsd <- all_rmsd[all_rmsd > 0]
zscores <- scale(log(all_rmsd))
sort(all_rmsd[zscores > 1.65])
```

*Please note* that the advantage in computation time increases with the number of features; for a small number of features parallel computing may be slower than the sequential approach due to its overhead.

<!-- ---------------------------------- -->
# Appendix
<!-- ---------------------------------- -->
## Protocols
The following protocols describe how this package can be used to perform the data analysis shown in the original *CellTrails* article.

### Chicken E15 Utricle Data

```{r, eval=FALSE}
# Load expression data
bundle <- readRDS(system.file("exdata", "bundle.rds", package="CellTrails"))

# Manifold Learning
se <- embedSamples(bundle)
d <- findSpectrum(se$eigenvalues, frac=100) #Similar to Figure 1E
latentSpace(bundle) <- se$components[, d]

# Clustering
states(bundle) <- findStates(bundle, min_size=0.01, 
                             min_feat=5, max_pval=1e-04, min_fc=2)

# Sample Ordering
bundle <- connectStates(bundle, l=10)
showTrajInfo(bundle)

bundle <- selectTrajectory(bundle, component=1)
bundle <- fitTrajectory(bundle)

# CellTrails maps
# Please note: For illustration purposes, the layout was 
# computed in yEd using functions write.ygraphml and 
# read.ygraphml, and is part of the CellTrails package
tl <- read.ygraphml(system.file("exdata", "bundle.graphml", 
                                package="CellTrails"))
trajLayout(bundle, adjust=TRUE) <- tl

# Define subtrail by adding a user-defined landmark
userLandmarks(bundle) <- "Cell-8-57"

# Analysis of Expression Dynamics
bundle <- addTrail(bundle, from="B3", to="H9", name="TrS")
bundle <- addTrail(bundle, from="B3", to="H1", name="TrES")
bundle <- addTrail(bundle, from="B3", to="U1", name="TrES*")

# Inter-trail comparison (similar to Figure 5B)
rmsd_all <- contrastTrailExpr(bundle, trail_names=c("TrS", "TrES"))
rmsd_all <- rmsd_all[rmsd_all > 0]
sort(rmsd_all[scale(log(rmsd_all)) > 1.65])

# -------------------------------
# Visualizations
# -------------------------------
# Plot size of clusters (similar to Figure 2E)
plotStateSize(bundle)

# Plot expression distribution
plotStateExpression(bundle, feature_name="OTOA")
plotStateExpression(bundle, feature_name="ATOH1")
plotStateExpression(bundle, feature_name="CALB2")
plotStateExpression(bundle, feature_name="ATP2B2")

# Plot manifold (similar to Figure S4F)
set.seed(1101)
gp <- plotManifold(bundle, color_by="phenoName", name="state")
manifold2D(bundle) <- gp
plotManifold(bundle, color_by="phenoName", name="fm143")
plotManifold(bundle, color_by="featureName", name="OTOA")
plotManifold(bundle, color_by="featureName", name="CALB2")

# Plot state trajectory graph (similar to Figure 1G)
plotStateTrajectory(bundle, color_by="phenoName", 
                    name="fm143", point_size=1.5, 
                    label_offset=4, component=1)
plotStateTrajectory(bundle, color_by="phenoName", 
                    name="origin", point_size=1.5, 
                    label_offset=4, component=1)
plotStateTrajectory(bundle, color_by="featureName", 
                    name="OTOA", point_size=5, 
                    label_offset=4, component=1)
plotStateTrajectory(bundle, color_by="featureName", 
                    name="ATOH1", point_size=5, 
                    label_offset=4, component=1)
plotStateTrajectory(bundle, color_by="featureName", 
                    name="CALB2", point_size=5, 
                    label_offset=4, component=1)

# Plot trajectory fit (similar to Figure 2E)
plotTrajectoryFit(bundle)

# Plot CellTrails maps (similar to Figure 3 and Table S2)
plotMap(bundle, color_by="phenoName", name="fm143")
plotMap(bundle, color_by="featureName", 
        name="ATOH1", type="raw")
plotMap(bundle, color_by="featureName", 
        name="ATOH1", type="surface.fit")
plotMap(bundle, color_by="featureName", 
        name="ATOH1", type="surface.se")
plotMap(bundle, color_by="featureName", 
        name="ATOH1", type="surface.fit", samples_only=TRUE)

# Plot landmarks
plotMap(bundle, color_by="phenoName", name="landmark")

# Plot trails (similar to Figure 4K)
plotTrail(bundle, name="TrS")
plotTrail(bundle, name="TrES")
plotTrail(bundle, name="TrES*")

# Plot single dynamics (similar to Figure 4B,G and Table S2)
plotDynamic(bundle, feature_name="CALB2", trail_name="TrES")
plotDynamic(bundle, feature_name="ATP2B2", trail_name="TrES")

# Compare dynamics (similar to Figure 6A)
plotDynamic(bundle, 
            feature_name=c("TECTA", "OTOA", "ATOH1", "POU4F3", 
                           "MYO7A", "CALB2", "SYN3", "SKOR2",
                           "ATP2B2", "LOXHD1", "MYO3A", "TMC2", 
                           "TNNC2"), trail_name="TrES")

plotDynamic(bundle, 
            feature_name=c("TECTA", "OTOA", "ATOH1", "POU4F3", 
                           "MYO7A", "CALB2", "SYN3", "SKOR2",
                           "ATP2B2", "LOXHD1", "MYO3A", "TMC2", 
                           "TNNC2"), trail_name="TrS")
```

### Mouse P1 Utricle Data

In the following, we provide a protocol to analyze the publicly-available dataset containing single-cell RNASeq measurements of 14,313 genes in 120 cells from P1 mouse utricles ([*GEO*](https://www.ncbi.nlm.nih.gov/geo/) accession code: GSE71982). Experimental metadata was generated during cell sorting (GFP and tdTomato fluorescence indicating major cell types). The processed data (`mmu_p1_utricle.rda`) can be downloaded as `r Biocpkg("SingleCellExperiment")` object from [here](https://github.com/elldc/CellTrails/raw/master/docs/mmu_p1_utricle.rds). The trajectory layout (`mmu_p1_utricle.graphml`) can be downloaded from [here](https://github.com/elldc/CellTrails/raw/master/docs/mmu_p1_utricle.graphml).

If you use this dataset for your research, please cite:

Burns JC, Kelly MC, Hoa M, Morell RJ, Kelley MW. "Single-cell RNA-Seq resolves cellular complexity in sensory organs from the neonatal inner ear". *Nat Commun.* 2015 Oct 15;6:8557. doi: 10.1038/ncomms9557.

```{r, eval=FALSE}
# Load expression data
p1utricle <- readRDS("mmu_p1_utricle.rds")

# Feature Selection
trajFeatureNames(p1utricle) <- filterTrajFeaturesByDL(p1utricle, threshold=2)
trajFeatureNames(p1utricle) <- filterTrajFeaturesByCOV(p1utricle, threshold=.5)
trajFeatureNames(p1utricle) <- filterTrajFeaturesByFF(p1utricle)

showTrajInfo(p1utricle)

# Manifold Learning
se <- embedSamples(p1utricle)
d <- findSpectrum(se$eigenvalues)
latentSpace(p1utricle) <- se$components[, d]

# Clustering (parameters account for low sample size)
states(p1utricle) <- findStates(p1utricle, max_pval=1e-3, min_feat=2)

# Sample Ordering
p1utricle <- connectStates(p1utricle)
p1utricle <- fitTrajectory(p1utricle)
showTrajInfo(p1utricle)

# CellTrails maps
tl <- read.ygraphml("mmu_p1_utricle.graphml")
trajLayout(p1utricle) <- tl

# Analysis of Expression Dynamics
p1utricle <- addTrail(p1utricle, from="H1", to="H3", name="Tr1")
p1utricle <- addTrail(p1utricle, from="H1", to="H2", name="Tr2")

# Inter-trail comparison
rmsd_all <- contrastTrailExpr(p1utricle, trail_names=c("Tr1", "Tr2"))
rmsd_all <- rmsd_all[rmsd_all > 0]
sort(rmsd_all[scale(log(rmsd_all)) > 1.65])

# Alternative: using parallel computing using doSNOW
library(doSNOW)
cpu.cl <- makeCluster(parallel::detectCores() * 2)
registerDoSNOW(cpu.cl)

fnames <- featureNames(p1utricle)
all_rmsd <- foreach(i=seq_along(fnames), .combine=rbind)  %dopar%  {
  g <- fnames[i]
  CellTrails::contrastTrailExpr(p1utricle, feature_name=g, 
                                trail_names=c("Tr1", "Tr2"), score="RMSD")
}
stopCluster(cpu.cl)
all_rmsd <- all_rmsd[, 1]
names(all_rmsd) <- fnames
all_rmsd <- all_rmsd[all_rmsd > 0]
zscores <- scale(log(all_rmsd))
sort(all_rmsd[zscores > 1.65])

# -------------------------------
# Visualizations
# -------------------------------
# Plot size of clusters (similar to Figure 7A)
plotStateSize(p1utricle)

# Plot expression distribution
plotStateExpression(p1utricle, feature_name="Otoa")
plotStateExpression(p1utricle, feature_name="Atoh1")
plotStateExpression(p1utricle, feature_name="Sox2")

# Plot manifold
set.seed(1101)
gp <- plotManifold(p1utricle, color_by="phenoName", name="state")
manifold2D(p1utricle) <- gp
plotManifold(p1utricle, color_by="phenoName", name="gate")
plotManifold(p1utricle, color_by="featureName", name="Otoa")
plotManifold(p1utricle, color_by="featureName", name="Fscn2")

# Plot state trajectory graph (similar to Figure 1G)
plotStateTrajectory(p1utricle, color_by="phenoName", 
                    name="gate", point_size=1.5, 
                    label_offset=4, component=1)
plotStateTrajectory(p1utricle, color_by="featureName", 
                    name="Otoa", point_size=5, 
                    label_offset=4, component=1)

# Plot trajectory fit (similar to Figure 7A)
plotTrajectoryFit(p1utricle)

# Plot CellTrails maps (similar to Figure 7C-E)
plotMap(p1utricle, color_by="phenoName", name="gate")
plotMap(p1utricle, color_by="featureName", 
        name="Atoh1", type="raw")
plotMap(p1utricle, color_by="featureName", 
        name="Atoh1", type="surface.fit")
plotMap(p1utricle, color_by="featureName", 
        name="Atoh1", type="surface.se")
plotMap(p1utricle, color_by="featureName", 
        name="Atoh1", type="surface.fit", 
        samples_only=TRUE)

# Plot landmarks
plotMap(p1utricle, color_by="phenoName", name="landmark")

# Plot trails (similar to Figure 7F)
plotTrail(p1utricle, name="Tr1")
plotTrail(p1utricle, name="Tr2")

# Plot single dynamics (similar to Figure 7I)
plotDynamic(p1utricle, feature_name="Fgf21", trail_name="Tr2")
plotDynamic(p1utricle, feature_name="Fgf21", trail_name="Tr1")

# Compare dynamics
plotDynamic(p1utricle, feature_name=c("Fscn1", "Fscn2"), trail_name="Tr2")
```

## Runtime
In this section, we illustrate that a *CellTrails* analysis can be performed in a reasonable period of time. The elapsed computational runtime of each function was measured on a MacBook Pro (Early 2015) with a 3.1 GHz Intel Core i7 processor, 16 GB 1867 MHz DDR3 RAM, and an Intel Iris Graphics 6100 1536 MB graphics card.

### Protocol: Chicken E15 Utricle Data
This dataset consists of 183 features and 1,008 samples. The computation time of the whole protocol as listed above took less then two minutes. Let's assume that computing the layout takes about two minutes (starting *yEd*, running the layouter, saving the file), then the total runtime is up to five minutes.

<!-- test with proc.time(); ... ; ptm <- proc.time() -->

### Protocol: Mouse P1 Utricle Data
This dataset consists of 14,313 features and 120 samples. The computation time of the whole protocol as listed above (with parallelization of the inter-trail dynamics comparison) took less then seven minutes. Let's assume that computing the layout takes about two minutes (starting *yEd*, running the layouter, saving the file), then the total runtime is up to 10 minutes.

## Session Info
We used _yEd_ version 3.14.4.  
The _R_ session and the system used to compile this document is listed below.

```{r}
sessionInfo()
```

<!-- ---------------------------------- -->
## References
<!-- ---------------------------------- -->

<!-- ---------------------------------- -->
<!-- FOOTNOTES ------------------------ --> 
<!-- ---------------------------------- -->
[^1]: http://www.yworks.com/products/yed
